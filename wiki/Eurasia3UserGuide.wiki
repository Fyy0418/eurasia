#labels Featured,Phase-Implementation,Phase-Support
=Eurasia3 用户指引=

http://eurasia.googlecode.com/files/cctv.jpg

_(当然了, 也是女人的最爱)_

===欢迎进入 Eurasia3 魔幻世界===

_本文档尚在编写阶段, 关于 Eurasia3 技术的任何问题可以向 [http://groups.google.com/group/eurasia-users Eurasia 邮件列表]提出, 感谢您的支持 :) _

[http://eurasia.svn.sourceforge.net/viewvc/eurasia/demo/bin/server.py?view=markup Eurasia3 Demo] 是一份全面展示 Eurasia3 功能, 且颇为可读的范例文档。

在本文档尚未完成之前, 阅读 [http://eurasia.svn.sourceforge.net/viewvc/eurasia/demo/bin/server.py?view=markup Eurasia3 Demo] 可以获取 Eurasia3 更多的高级功能。

_──── 2007 年 12 月 2 日, 沈崴于太湖南岸_

===在阅读本文档之前===

本文档不是 HTTP 协议的小灶, HTTP 协议的相关知识对 Eurasia3 来说不是必须的,

但对您了解、使用 Eurasia3 来说会很有帮助。

==勾人胃口的入门级功能==

Eurasia3 当然也照例实现了一些常规 Web 框架的功能, 不错, 重复制造了轮子。

不过请相信我, Eurasia3 所关注的并不是这些 ──── 他只是顺手实现了而已。

──── 尽管 Eurasia3 似乎要做得更好些。

===在所有事情开始之前, 您需要 ──── 安装===

您需要:
 * Unix 或兼容系统
 * Stackless Python 2.5 或更高版本

很废柴, 其实这里不必贴过程出来的 ……

{{{
tar xzf Eurasia-3.x.x.tar.gz
cd Eurasia-3.x.x
/PATH/TO/STACKLESS/bin/python2.5 setup.py install
}}}

===Hello world!===

现在, 是时候编写我们第一个 Web 服务器了。

{{{
# 我是 hello.py
from Eurasia.web import config, mainloop

def controller(client):
	client.write('hello world!')
	# print >> client, 'hello world!' # 这样也行

	client.shutdown()
	# client.closed = True # 效果差不多

config(
	controller=controller,
	port = 8080 )

mainloop()
}}}

启动服务器:

{{{
/PATH/TO/STACKLESS/bin/python2.5 hello.py
}}}

现在, 您可以尝试访问 'http://localhost:8080/' 这个地址了。

===client 参数===

参数 "client" 提供的一些重要信息:

||client.path||提供了请求的 url, 是一个从根 ("/") 开始的字符串||
||client.metho||提供了请求的方法, 通常是 "get" 或者 "post" (小写)||
||client.address||提供了请求者的 IP 以及端口信息||
||client['header-name']||提供了对 HTTP 头 (Header) 的访问, 注意, "header-name" 应该是小写的||
||client.uid||传说中的 Session Id, 具体用法后面会讲到||
||client.pid||传说中的 Socket fileno||
||client.closed||设为 True, 则 Eurasia3 会自动关闭和浏览器的连接||

好的, 您现在知道如何取 POST 报文长度了吗?

很简单, 使用 `client['content-length']` 就可以了, *注意* 请小写 "header-name"!

让我们回顾一下第一个 "hello world" 程序, client 还提供了以下两个方法:

||client.write(str)||向浏览器写数据||
||client.shutdown()||和 client.closed = True 不同, shutdown 会*立即*关闭到浏览器的连接||

事实上, 对于基于 GET 方法的简单 HTTP 请求, client 已经可以应付了。

*注意* , 以 client 来处理请求远没有您想像中那么小儿科,

他能将动态页面的响应能力提高到接近或者超过 Apache (静态页面响应速度) 的程度, 显然这是比较恐怖的。

===我们照例提供 Response 接口===

当然了, 下面您会发现, client 参数能做到 Response 接口所有的事情

──── 只是 Response 更酷而已。

{{{
from Eurasia.web import config, mainloop
from Eurasia.web import Response

def controller(client):
	resp = Response(client)

	resp['Content-Type'] = 'text/html; charset=utf-8' # 我可以写 Header 了!

	print >> resp, 'hello world!'
	#resp.write('hello world!') # 这样也行

	resp.close()

config(
	controller=controller,
	port = 8080 )

mainloop()
}}}

===你在找表单变量吗?===

Form 来啦!

当 URL 是 `"http://localhost:8080/?a=1&b=2"` 时, Form 能得到这些提交的表单变量。

Form 是这样的一个字典: `{'a': 1, 'b': 2}`。然后, POST 方法也是支持的。

{{{
from Eurasia.web import config, mainloop
from Eurasia.web import Response, Form, OverLimit

def controller(client):
	resp = Response(client)
	resp['Content-Type'] = 'text/html; charset=utf-8'

	try:
		form = Form(client,

			max_size=10000) # 限制 Form (POST 模式) 上传内容的大小
			                # 默认 1048576 字节

		        	        # 当 form 超过限制, 会得到 OverLimit 异常
			                # client 会自动 shutdown
	except OverLimit:
		# client 已经 shutdown, 我除了写日志无事可干

		# 通常情况下, 我在 HTML 页面里已经限制了可提交内容的大小,
		# 这应该是一次 Crack 行为
		pass


	print >> resp, '你的表单提交了这些变量:',
	for key, value in form.items():
		print >> resp, key, '->', value

	resp.close()

config(
	controller=controller,
	port = 8080 )

mainloop()
}}}

===我们还有 Request 接口===

Request 恰和 Response 相反, Request 可以读取 POST 报文的 Body 部分。

但是请注意, 不是 GET 报文 (GET 报文没有 Body), 否则您将得到一个 MethodError 异常。

{{{
from Eurasia.web import config, mainloop
from Eurasia.web import Request, Response, MethodError, OverLimit

def controller(client):
	resp = Response(client)
	resp['Content-Type'] = 'text/html; charset=utf-8'
	try:
		req  = Request(client,

			max_size=10000 ) # 超出 10000 字节, 读取时将抛出 OverLimit 异常
			                 # (而 Form 的 OverLimit 是发生在初始化时)
			                 # 服务器将自动关闭

		        	         # 默认 1048576 字节
	except MethodError:
		print >> resp, '[Request 接口只支持 POST 方法]'
		resp.close()
		return

	try:
		s  = req.read(100)     # 我可以这么读
		s += req.readline(100) # 也可以这么读
		s += req.readline()    # 还可以这么读
		s += req.read()        # shut up, 读取所有内容 now!
	except OverLimit:
		# client 已经挂掉, 我无事可干
		return

	print >> resp, s
	resp.close()

config(
	controller=controller,
	port = 8080 )

mainloop()
}}}

下面是天杀的测试页面, 贴到本地文件里, 用浏览器打开吧 (也别忘了启动上面的服务器程序)。

{{{
<html>
<!-- 我是测试页面, 我会发出 POST 数据 -->
<form method="post" action="http://localhost:8080/">
<input type="text" name="a" value="...">
<input type="text" name="b" value="...">
<input type="submit">
</form>
</html>
}}}

最后, Form 是基于 Request 实现的。

可想而知, 在遇到 POST 请求时 Form 调用的是 Request.read(), 读完整个 POST 报文。

因此, 在*绝大多数情况下请勿*混用 Form 和 Request。

===Response 和 Request 的比较研究===

||接口名称||Client||Response||Request||Form||
||uid 属性||读取 Session Id||写 Session Id||读取 Session Id||读取 Session Id||
||pid 属性||读取 Socket fileno|| ||读取 Socket Fileno||读取 Socket Fileno||
||read(size=None)|| || ||读取 POST 报文体|| ||
||readline(size=None)|| || ||行读取 POST 报文体|| ||
||write(s)||直写, 立即发生 IO 行为||写缓冲区|| || ||
||close()|| ||写出缓冲区, 并关闭连接|| || ||
||`__getitem__`|| || ||取 HTTP Header||读取表单||
||`__setitem__`|| ||向缓冲区写 HTTP Header|| || ||

Response 与 Request 基本上是一一对应的, 互为逆操作。

===恐怖的 IO 错误!===

当我们使用 Eurasia3 时, 如果我们未将 POST 报文读取完成便开始向浏览器进行回复,

我们将得到一个 IOError, 并杀死这个 Socket (Client)。

所以在遇到 POST 报文时, 在进行 Response 之前, 我们需要先使用 Request.read() 读完整个 POST 报文。

当然最简单地, 调用 Form 接口, Form() 调用会自动读取整个 POST 请求。

当然使用上面的 Response 对象, Response.write() 并不会立即产生 IO,

只有在执行 Response.close() 时才会有实际的发送操作,

因此对 Response 来说, 你可以边读边写。

而 Client.write() 会立即产生 IO, 因此 Client.write()

必须在 Request 完成所有 POST 报文的读操作之后调用。

http://bbs.chinaunix.net/customavatars/604098.jpg http://bbs.chinaunix.net/customavatars/604098.jpg http://bbs.chinaunix.net/customavatars/604098.jpg http://bbs.chinaunix.net/customavatars/604098.jpg

http://bbs.chinaunix.net/customavatars/604098.jpg http://bbs.chinaunix.net/customavatars/604098.jpg http://bbs.chinaunix.net/customavatars/604098.jpg http://bbs.chinaunix.net/customavatars/604098.jpg

==像 CherryPy 和 Django 一样工作==

绝大多数黑客在第一时间内都会发现 Eurasia3 其实是一个比 Django 更为底层的框架。

当然, 更底层并不意味着更难用 ──── 高级而难用的框架我们已经见得太多了。

= 未完待续 …… =