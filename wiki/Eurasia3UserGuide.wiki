#labels Featured,Phase-Implementation,Phase-Support
=Eurasia3 用户指引=

http://eurasia.googlecode.com/files/cctv.jpg

===欢迎进入 Eurasia3 魔幻世界===

_本文档尚在编写阶段, 关于 Eurasia3 技术的任何问题可以向 [http://groups.google.com/group/eurasia-users Eurasia 邮件列表]提出, 感谢您的支持 :) _

[http://eurasia.svn.sourceforge.net/viewvc/eurasia/demo/bin/server.py?view=markup Eurasia3 Demo] 是一份全面展示 Eurasia3 功能, 且颇为可读的范例文档。

在本文档尚未完成之前, 阅读 [http://eurasia.svn.sourceforge.net/viewvc/eurasia/demo/bin/server.py?view=markup Eurasia3 Demo] 可以获取 Eurasia3 更多的高级功能。

===在阅读本文档之前===

本文档不是 HTTP 协议的小灶, HTTP 协议的相关知识对 Eurasia3 来说不是必须的,

但对您了解、使用 Eurasia3 来说会很有帮助。

==吊人胃口的入门级功能==

Eurasia3 当然也照例实现了一些常规 Web 框架的功能, 不错, 重复制造了轮子。

不过请相信我, Eurasia3 所关注的并不是这些 ──── 他只是顺手实现了而已。

──── 尽管 Eurasia3 似乎要做得更好些。

===安装===

您需要:
 * Unix 或兼容系统
 * Stackless Python 2.5 或更高版本

很废柴, 其实这里不必贴过程出来的 ……

{{{
tar xzf Eurasia-3.x.x.tar.gz
cd Eurasia-3.x.x
/PATH/TO/STACKLESS/bin/python2.5 setup.py install
}}}

===Hello world!===

现在, 是时候编写我们第一个 Web 服务器了。

{{{
# 我是 hello.py
from Eurasia.web import config, mainloop

def controller(conn):
	conn.write('hello world!')

	conn.shutdown()
	# conn.closed = True # 效果一样

config(
	controller=controller,
	port = 8080 )

mainloop()
}}}

启动服务器:

{{{
/PATH/TO/STACKLESS/bin/python2.5 hello.py
}}}

现在, 您可以尝试访问 'http://localhost:8080/' 这个地址了。

_您也可以尝试使用诸如 ab 这一类测试工具来体会一下 Eurasia3 的强大_

===参数 "conn" 提供的一些重要信息===

||conn.path||提供了请求的 url, 是一个从根 ("/") 开始的字符串||
||conn.metho||提供了请求的方法, 通常是 "get" 或者 "post" (小写)||
||conn.address||提供了请求者的 IP 以及端口信息||
||conn['header-name']||提供了对 HTTP 头 (Header) 的访问, 注意, "header-name" 应该是小写的||
||conn.uid||传说中的 Session Id, 具体用法后面会讲到||


===我们照例提供 Response 接口===

当然了, 下面您会发现, conn 参数能做到 Response 接口所有的事情

──── 只是 Response 更酷而已。

{{{
from Eurasia.web import config, mainloop
from Eurasia.web import Response

def controller(conn):
	resp = Response(conn)

	resp['Content-Type'] = 'text/html; charset=utf-8' # 我可以写 Header 了!

	print >> resp, 'hello world!'
	#resp.write('hello world!') # 这样也行

	resp.close()

config(
	controller=controller,
	port = 8080 )

mainloop()
}}}

===你在找表单变量吗?===

Form 来啦!

当 URL 是 `"http://localhost:8080/?a=1&b=2"` 时, Form 能得到这些提交的表单变量。

Form 是这样的一个字典: `{'a': 1, 'b': 2}`。然后, POST 方法也是支持的。

{{{
from Eurasia.web import config, mainloop
from Eurasia.web import Response, Form

def controller(conn):
	form = Form(conn,

		max_size=10000) # 限制 Form (POST 模式) 上传内容的大小
		                # 默认 1048576 字节

	resp = Response(conn)
	resp['Content-Type'] = 'text/html; charset=utf-8' # 写 Header

	print >> resp, '你的表单提交了这些变量:', form

	resp.close()

config(
	controller=controller,
	port = 8080 )

mainloop()
}}}

===报文头 (HTTP Header) 在哪里?===

很简单, 取 `conn["header-name"]` 就可以了, 请小写 header 名称

比如 conn['content-length']

===我们还有 Request 接口===

Request 恰和 Response 相反, Request 可以读取 POST 报文的 Body 部分。

但是请注意, 不是 GET 报文 (GET 报文没有 Body), 否则您将得到一个 MethodError 异常。

{{{
from Eurasia.web import config, mainloop
from Eurasia.web import Request, Response, MethodError, OverLimit

def controller(conn):
	try:
		req  = Request(conn,

			max_size=10000 ) # 超出 10000 字节, 读取时将抛出 OverLimit 异常
			                 #   服务器将自动关闭

		        	         # 默认 1048576 字节
		s = ''
	except MethodError:
		s = '[仅支持 POST 报文]'

	if not s:
		try:
			s += req.read(100)
			s += req.readline(100)
			s += req.readline()
			s += req.read() # 读取所有内容
		except OverLimit:
			s = '[超出报文长度限制]'

	resp = Response(conn)

	resp['Content-Type'] = 'text/html; charset=utf-8'

	resp.close()

config(
	controller=controller,
	port = 8080 )

mainloop()
}}}

启动服务器以后, 您可以通过这个页面来测试这个程序:

{{{
<html>
<!-- 我是测试页面 -->
<form method="post" action="http://localhost:8080/">
<input type="text" name="a" value="...">
<input type="text" name="b" value="...">
<input type="submit">
</form>
</html>
}}}

===Form 是基于 Request 实现的===

Form 调用相当于 Request.to_form 调用

{{{
form = Request(conn, max_size=10000)
form2 = form.to_form() # 将 form 转换成 Form 对象
                       # to_form() 调用返回 form 本身

form.read() # 报文已经读完, 故只能得到空字符串 ''
}}}

Form 调用会自动读取全部 POST 报文, 所以当调用 Form 接口或者 to_form() 以后,

你无法再使用 Request 对象读取报文。

===恐怖的 IO 错误!===

当我们使用 Eurasia3 时, 如果我们未将 POST 报文读取完成便开始向浏览器进行回复,

我们将得到一个 IOError, 并杀死这个 Socket。

所以在遇到 POST 报文时, 在进行 Response 之前, 我们需要先使用 Request.read() 读完整个 POST 报文。

当然最简单地, 调用 Form 接口, Form() 调用会自动读取整个 POST 请求。

= 未完待续 …… =