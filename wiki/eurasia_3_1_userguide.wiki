#summary EURASIA 用户手册（3.1 版）
#labels Deprecated

<wiki:toc max_depth="2" /> 


|| || || ||
|| || ||
|| ||


=快速开始=

我们将从最简单的 hello world 开始，通过一些范例程序，快速掌握 eurasia 的特点。

这首先是一个 web 程序。


==hello world==

{{{
#!/usr/bin/python
#-*- coding: utf-8 -*-
#filename: test.py

from eurasia.web import httpserver, mainloop
def handler(httpfile):
    httpfile['Content-Type'] = 'text/html'
    httpfile.write('<html>hello world!</html>')
    httpfile.close()

httpd = httpserver(('', 8080), handler)
httpd.start()
mainloop()
}}}

简单地把 handler 绑定到本机的 8080 端口。所有发往这个端口的 http 请求都会得到一个 hello world 的响应。

执行脚本，启动服务器。

{{{
$/usr/bin/python2 test.py
}}}

  * 一次可以通过 httpserver 创建多个 http 服务器。
  * http 服务器通过 start() 启动，用 stop() 暂停。
  * mainloop() 主循环是每个 eurasia 程序都必须要有的。


==httpfile 对象==

通过操作 httpfile 对象以获取用户请求并完成响应。

request 操作:

|| property || httpfile.method || 通常是“GET”或“POST” ||
|| property || httpfile.path_info || 请求的路径信息 ||
|| property || httpfile.query_string || 路径中“?”之后的部分 ||
|| property || httpfile.cookie || 得到客户端 cookie（Cookie.SimpleCookie 对象）无则返回 None ||
|| dict get || httpfile{{{[}}}_*headername*_{{{]}}} || 得到指定头部 ||

response 操作:

|| property || httpfile.status || http 响应状态，默认是 200 ||
|| property || httpfile.cookie || 向客户端发送一个 Cookie 对象（比如 Cookie.SimpleCookie） ||
|| dict set || httpfile{{{[}}}_*headername*_{{{]}}} || 发送指定头部 ||
|| method || httpfile.write(_*data*_, _*timeout*=-1_) || 发送指定内容，默认无超时 ||
|| method || httpfile.close(_*timeout*=-1_) || 完成并终止本次响应，默认无超时 ||

下面将是一个完整的例子（文件服务器）：

{{{
#-*- coding: utf-8 -*-
import os.path
from eurasia.web import httpserver, mainloop
def handler(httpfile):
    # 注意，直接组合路径不安全
    filename = '/var/www' + httpfile.path_info
    if not os.path.exists(filename):
        httpfile.status = 404 # 文件未找到
        httpfile.write('<h1>Not Found</h1>')
        return httpfile.close()
    if os.path.isdir(filename):
        httpfile.status = 403 # 不支持列出目录
        httpfile.write('<h1>Forbidden</h1>')
        return httpfile.close()
    httpfile['Content-Type'] = 'application/octet-stream'
    data = open(filename).read()
    httpfile.write(data)
    httpfile.close()

httpd = httpserver(('', 8080), handler)
httpd.start()
mainloop()
}}}

  * 虽然 httpfile 形似 dict，但是 dict get 仅用于读取 request 头部，dict set 仅用于写入 response 头部。
    # 这意味着从 {{{httpfile[...]}}} 获取的内容和写入 {{{httpfile[...]}}} 的内容，一般*并不匹配*。
    # httpfile.cookie 亦然。

  * 这里直接对路径进行相加，*是不安全的*，仅用于演示。
  * 这里对磁盘文件的读取操作会阻塞整个程序，eurasia 带有文件 IO 的协程版本，将于后文中详述。


|| || || ||
|| || ||
|| ||


=标准 web 服务器=

现在进入进阶主题。

首先通过 httpserver(_*addr*_, _*handler*_) 创建标准 http 服务器。

==地址格式==

接口 httpserver 允许多种形式的 addr 参数。

使用字符串指定地址：

{{{
httpserver('127.0.0.1:8080', handler)  # IPv4 地址，端口 8080
httpserver('[::1]:8080', handler)  # IPv6 地址
httpserver(':8080', handler)  # 地址是 ''，端口 8080
}}}

使用 tuple 类型的地址（默认 family 为 AF_INET）：

{{{
httpserver(('127.0.0.1', 8080), handler)
httpserver(('::1', 8080), handler)
}}}

同时指定地址及 family：

{{{
from socket import AF_INET6, AF_UNIX
from eurasia.web import httpserver

httpserver((('::1', 8080), AF_INET6), handler)
httpserver(('/var/httpd/httpd.sock', AF_UNIX), handler)  # unix socket
}}}

使用已打开的 fileno（默认 family 为 AF_INET）：

{{{
httpserver(0, handler)  # 绑定到 fileno 为 0 的资源描述符
}}}

使用 fileno 并指定 family：

{{{
from socket import AF_INET6
from eurasia.web import httpserver

httpserver((AF_INET6, 0), handler)
}}}

==CGI/1.1 规范适配==

httpfile 对象是整个服务器的关键接口，其设计在很大程度上与 CGI/1.1 规范适配，以下是一些对应关系：

|| || 接口： || CGI/1.1 对应： ||
|| dict get || httpfile.environ{{{[}}}_*envname*_{{{]}}} || 环境变量 ||
|| method || httpfile.read(_*size*=-1_, _*timeout*=-1_) || 标准输入 ||
|| method || httpfile.readline(_*size*=-1_, _*timeout*=-1_) || 标准输入 ||
|| method || httpfile.write(_*data*_, _*timeout*=-1_) || 标准输出 ||
|| method || httpfile.sendall(_*data*_, _*timeout*=-1_) || 标准输出 ||

仿照 CGI 编程：

{{{
}}}