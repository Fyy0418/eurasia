#summary EURASIA 用户手册（3.1 版）
#labels Deprecated

<wiki:toc max_depth="2" /> 


|| || || ||
|| || ||
|| ||


=快速开始=

我们将从最简单的 hello world 开始，通过一些范例程序，快速掌握 eurasia 的特点。

这首先是一个 web 程序。


==hello world==

{{{
#!/usr/bin/python
#-*- coding: utf-8 -*-
#filename: test.py

from eurasia.web import httpserver, mainloop
def handler(httpfile):
    httpfile['Content-Type'] = 'text/html'
    httpfile.write('<html>hello world!</html>')
    httpfile.close()

httpd = httpserver(('', 8080), handler)
httpd.start()
mainloop()
}}}

简单地把 handler 绑定到本机的 8080 端口。所有发往这个端口的 http 请求都会得到一个 hello world 的响应。

执行脚本，启动服务器。

{{{
$/usr/bin/python2 test.py
}}}

  * 一次可以通过 httpserver 创建多个 http 服务器
  * http 服务器通过 start() 启动，用 stop() 暂停
  * mainloop() 主循环是每个 eurasia 程序都必须要有的


==httpfile 对象==

通过操作 httpfile 对象以获取用户请求并完成响应。

request 操作:

|| property || httpfile.method || 通常是“GET”或“POST” ||
|| property || httpfile.path_info || 请求的路径信息 ||
|| property || httpfile.query_string || 路径中“?”之后的部分 ||
|| property || httpfile.cookie || 得到客户端 cookie（Cookie.SimpleCookie 对象）无则返回 None ||
|| dict get || httpfile{{{[}}}_*headername*_{{{]}}} || 得到指定头部 ||

response 操作:

|| property || httpfile.status || http 响应状态，默认是 200 ||
|| property || httpfile.cookie || 向客户端发送一个 Cookie 对象（比如 Cookie.SimpleCookie） ||
|| dict set || httpfile{{{[}}}_*headername*_{{{]}}} || 发送指定头部 ||
|| method || httpfile.write(_*data*_, _*timeout*=-1_) || 发送指定内容，默认无超时 ||
|| method || httpfile.close(_*timeout*=-1_) || 完成并终止本次响应，默认无超时 ||

下面将是一个完整的例子（文件服务器）：

{{{
#-*- coding: utf-8 -*-
import os.path
from eurasia.web import httpserver, mainloop
def handler(httpfile):
    # 注意，直接组合路径不安全
    filename = '/var/www' + httpfile.path_info
    if not os.path.exists(filename):
        httpfile.status = 404 # 文件未找到
        httpfile.write('<h1>Not Found</h1>')
        return httpfile.close()
    if os.path.isdir(filename):
        httpfile.status = 403 # 不支持列出目录
        httpfile.write('<h1>Forbidden</h1>')
        return httpfile.close()
    httpfile['Content-Type'] = 'application/octet-stream'
    data = open(filename).read()
    httpfile.write(data)
    httpfile.close()

httpd = httpserver(('', 8080), handler)
httpd.start()
mainloop()
}}}

  * 虽然 httpfile 形似 dict，但是 dict get 仅用于读取 request 头部，dict set 仅用于写入 response 头部
    # 这意味着从 {{{httpfile[...]}}} 获取的内容和写入 {{{httpfile[...]}}} 的内容，一般*并不匹配*
    # httpfile.cookie 亦然

  * 这里直接对路径进行相加，*是不安全的*，仅用于演示
  * 这里对磁盘文件的读取操作会阻塞整个程序，eurasia 带有文件 IO 的协程版本，将于后文中详述


|| || || ||
|| || ||
|| ||


=标准 web 服务器=

进入正题。

首先通过 httpserver(_*addr*_, _*handler*_) 创建标准 http 服务器。

==地址格式==

接口 httpserver 允许多种形式的 addr 参数。

使用字符串指定：

{{{
httpserver('127.0.0.1:8080', handler)  # IPv4 地址，端口 8080
httpserver('[::1]:8080', handler)  # IPv6 地址
httpserver(':8080', handler)  # 本机 8080 端口
}}}

使用 tuple 指定（默认 AF_INET）：

{{{
httpserver(('127.0.0.1', 8080), handler)
httpserver(('::1', 8080), handler)
}}}

同时指定地址及 family：

{{{
from socket import AF_INET6, AF_UNIX
from eurasia.web import httpserver

httpserver((('::1', 8080), AF_INET6), handler)
httpserver(('/var/httpd.sock', AF_UNIX), handler)  # unix socket
}}}

使用已打开的 fileno（默认 AF_INET）：

{{{
httpserver(0, handler)  # 绑定到 fileno 为 0 的资源描述符
}}}

使用 fileno 并指定 family：

{{{
from socket import AF_INET6
from eurasia.web import httpserver

httpserver((AF_INET6, 0), handler)
}}}

==启动和暂停服务器==

通过 httpserver.start() 和 httpserver.stop() 启动和暂停服务器，暂停后的服务器可以通过 httpserver.start() 重新启动。

{{{
# -*- coding: utf-8 -*-
from eurasia.web import httpserver, mianloop

# 工作服务器，绑定到 8080 总是返回 hello world
def handler(httpfile):
    httpfile.write('hello world!')
    httpfile.close()

httpd = httpserver(':8080', handler)
httpd.start()

# 管理服务器，绑定到 8090
def manager(httpfile):
    # 如果请求地址是 /start 则启动工作服务器
    if httpfile.path_info == '/start':
        httpd.start()
   # 如果请求地址是 /pause 则停止工作服务器
    elif httpfile.path_info == '/pause':
        httpd.stop()

man = httpserver('8090', manager)
man.start()

# 执行调度
mainloop()
}}}

注意区分 httpserver.start() 和 mainloop()：
  * mainloop() 是整个程序的调度器，每个 eurasia 程序都必须要调用一次 mainloop() 以启动协程调度
  * httpserver.start() 和调度无关，只是让服务器进入请求监听状态
  * httpserver 可以有多个，而 mainloop() 只有一个

==CGI 规范适配==

httpfile 对象是整个服务器的关键接口，其设计在很大程度上与 CGI/1.1 规范适配，以下是一些对应关系：

|| 接口类型： || 接口描述： || CGI 对应： ||
|| dict get || httpfile.environ{{{[}}}_*envname*_{{{]}}} || 环境变量 ||
|| method || httpfile.read(_*size*=-1_, _*timeout*=-1_) || 标准输入 ||
|| method || httpfile.readline(_*size*=-1_, _*timeout*=-1_) || 标准输入 ||
|| method || httpfile.write(_*data*_, _*timeout*=-1_) || 标准输出 ||

可以通过 httpfile.environ{{{[}}}_*envname*_{{{]}}} 提取的环境变量有：

|| 环境变量： || 变量描述： || example： ||
|| REQUEST_METHOD || 请求的方法 || "GET"、"POST" ||
|| SERVER_PROTOCOL || 请求协议及版本 || "HTTP/1.1" ||
|| REMOTE_ADDR || 连入客户端的地址和端口 || ("192.168.0.2", 5566) ||
|| REMOTE_PORT || 连入客户端的端口 || 5566 ||
|| REQUEST_URI || 完整 uri || "/login?username=tom&passwd=***" ||
|| PATH_INFO || 页面地址 || "/login" ||
|| QUERY_STRING || 请求参数 || "username=tom&passwd=***" ||
|| CONTENT_TYPE || POST 等报文类型 || "application/x-www-form-urlencoded" ||
|| CONTENT_LENGTH || POST 等报文长度 || 999 ||
|| HTTP{{{_}}}_*HEADERNAME*_ || 请求头部 || 比如 HTTP_REFER 获得 "http://www.google.com/" ||

同样可以通过 httpfile.request_uri、httpfile.path_info、httpfile.query_string 取出相应环境变量并设置：

{{{
# 操作 httpfile.request_uri 会同时影响到 PATH_INFO 和 QUERY_STRING
httpfile.request_uri = '/login?username=tom&passwd=***'
print httpfile.path_info, httpfile.query_string  # 分别是 "/login" 和 "username=tom&passwd=***"
print httpfile.environ['PATH_INFO'], httpfile.environ['QUERY_STRING']  # 同上

# 操作 httpfile.path_info 会影响到 REQUEST_URI
httpfile.path_info = '/check'
print httpfile.request_uri  # uri 变成 "/check?username=tom&passwd=***"，query_string 不变
print httpfile.environ['REQUEST_URI']  # 同上

# 操作 httpfile.query_string 会影响到 REQUEST_URI
httpfile.query_string = 'username=jerry&passwd=***'
print httpfile.request_uri  # uri 变成 "/check?username=jerry&passwd=***"，path_info 不变
}}}

  * 对 httpfile.request_uri、httpfile.path_info、httpfile.query_string 进行设置这三个变量会联动
  * 设置 httpfile.environ 这三个变量*不会*发生联动，一般避免直接通过 httpfile.environ 操作这三个变量

==解读请求==

通过 httpfile.read(_*size*=-1_, _*timeout*=-1_) 和 httpfile.readline(_*size*=-1_, _*timeout*=-1_) 可以直接读取 POST 等请求报文。

eurasia.cgietc 模块提供了用于解析 POST 形式表单的工具 form(_*httpfile*_, _*max_size*=1048576_, _*timeout*=-1_)：
  * 需要指定一个 httpfile 对象
  * 使用 max_size 限定允许用户提交表单的最大字节数，超过限制会抛出 ValueError 并立即杀死客户端，默认最多传输 1M 数据
  * 使用 timeout 指定读取表单的超时时间
  * 使用 dict 返回解析的表单
    * 正常情况下每个表单项的取值都是 str
    * 如果提交了多个同名的表单项，那么该表单项取值就是一个 list，在其中保存多个 str 值

{{{
# -*- conding: utf-8 -*-
from eurasia.cgietc import form
from eurasia.web import httpserver, mainloop

def handler(httpfile):
    form1 = form(httpfile)

}}}

  * 注意，httpfile.read() / httpfile.readline() *不能与 form() 混用*