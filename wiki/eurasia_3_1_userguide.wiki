#summary EURASIA 用户手册（3.1 版）
#labels Deprecated

<wiki:toc max_depth="2" /> 


|| || || ||
|| || ||
|| ||


=快速开始=

我们将从最简单的 hello world 开始，通过一些范例程序，快速掌握 eurasia 的特点。

这首先是一个 web 程序。


==hello world==

{{{
#!/usr/bin/python
#-*- coding: utf-8 -*-
#filename: test.py

from eurasia.web import httpserver, mainloop
def handler(httpfile):
    httpfile['Content-Type'] = 'text/html'
    httpfile.write('<html>hello world!</html>')
    httpfile.close()

httpd = httpserver(('', 8080), handler)
httpd.start()
mainloop()
}}}

简单地把 handler 绑定到本机的 8080 端口。所有发往这个端口的 http 请求都会得到一个 hello world 的响应。

执行脚本，启动服务器。

{{{
$/usr/bin/python2 test.py
}}}

  * 一次可以通过 httpserver 创建多个 http 服务器
  * http 服务器通过 start() 启动，用 stop() 暂停
  * mainloop() 主循环是每个 eurasia 程序都必须要有的


==httpfile 对象==

通过操作 httpfile 对象以获取用户请求并完成响应。

request 操作:

|| property || httpfile.method || 通常是“GET”或“POST” ||
|| property || httpfile.path_info || 请求的路径信息 ||
|| property || httpfile.query_string || 路径中“?”之后的部分 ||
|| property || httpfile.cookie || 得到客户端 cookie（Cookie.SimpleCookie 对象）无则返回 None ||
|| dict get || httpfile{{{[}}}_*headername*_{{{]}}} || 得到指定头部 ||

response 操作:

|| property || httpfile.status || http 响应状态，默认是 200 ||
|| property || httpfile.cookie || 向客户端发送一个 Cookie 对象（比如 Cookie.SimpleCookie） ||
|| dict set || httpfile{{{[}}}_*headername*_{{{]}}} || 发送指定头部 ||
|| method || httpfile.write(_*data*_, _*timeout*=-1_) || 发送指定内容，默认无超时 ||
|| method || httpfile.close(_*timeout*=-1_) || 完成并终止本次响应，默认无超时 ||

下面将是一个完整的例子（文件服务器）：

{{{
#-*- coding: utf-8 -*-
import os.path
from eurasia.web import httpserver, mainloop
def handler(httpfile):
    # 注意，直接组合路径不安全
    filename = '/var/www' + httpfile.path_info
    if not os.path.exists(filename):
        httpfile.status = 404 # 文件未找到
        httpfile.write('<h1>Not Found</h1>')
        return httpfile.close()
    if os.path.isdir(filename):
        httpfile.status = 403 # 不支持列出目录
        httpfile.write('<h1>Forbidden</h1>')
        return httpfile.close()
    httpfile['Content-Type'] = 'application/octet-stream'
    data = open(filename).read()
    httpfile.write(data)
    httpfile.close()

httpd = httpserver(('', 8080), handler)
httpd.start()
mainloop()
}}}

  * 虽然 httpfile 形似 dict，但是 dict get 仅用于读取 request 头部，dict set 仅用于写入 response 头部
    # 这意味着从 {{{httpfile[...]}}} 获取的内容和写入 {{{httpfile[...]}}} 的内容，一般_*并不匹配*_
    # httpfile.cookie 亦然

  * 这里直接对路径进行相加，_*是不安全的*_，仅用于演示
  * 这里对磁盘文件的读取操作会阻塞整个程序，eurasia 带有文件 IO 的协程版本，将于后文中详述


|| || || ||
|| || ||
|| ||


=标准 web 服务器=

进入正题。首先通过：

|| httpserver(_*addr*_, _*handler*_) ||

创建标准 http 服务器。

==地址格式==

接口 httpserver 允许多种形式的 addr 参数。

使用字符串指定：

{{{
httpserver('127.0.0.1:8080', handler)  # IPv4 地址，端口 8080
httpserver('[::1]:8080', handler)  # IPv6 地址
httpserver(':8080', handler)  # 本机 8080 端口
}}}

使用 tuple 指定（默认 AF_INET）：

{{{
httpserver(('127.0.0.1', 8080), handler)
httpserver(('::1', 8080), handler)
}}}

同时指定地址及 family：

{{{
from socket import AF_INET6, AF_UNIX
from eurasia.web import httpserver

httpserver((('::1', 8080), AF_INET6), handler)
httpserver(('/var/httpd.sock', AF_UNIX), handler)  # unix socket
}}}

使用已打开的 fileno（默认 AF_INET）：

{{{
httpserver(0, handler)  # 绑定到 fileno 为 0 的资源描述符
}}}

使用 fileno 并指定 family：

{{{
from socket import AF_INET6
from eurasia.web import httpserver

httpserver((AF_INET6, 0), handler)
}}}

==启动和暂停服务器==

通过：

|| httpserver.start() ||

和

|| httpserver.stop() ||

启动和暂停服务器，暂停后的服务器可以通过 httpserver.start() 重新启动。

{{{
# -*- coding: utf-8 -*-
from eurasia.web import httpserver, mianloop

# 工作服务器，绑定到 8080 总是返回 hello world
def handler(httpfile):
    httpfile.write('hello world!')
    httpfile.close()

httpd = httpserver(':8080', handler)
httpd.start()

# 管理服务器，绑定到 8090
def manager(httpfile):
    # 如果请求地址是 /start 则启动工作服务器
    if httpfile.path_info == '/start':
        httpd.start()
   # 如果请求地址是 /pause 则停止工作服务器
    elif httpfile.path_info == '/pause':
        httpd.stop()

man = httpserver('8090', manager)
man.start()

# 执行调度
mainloop()
}}}

注意区分 httpserver.start() 和 mainloop()：
  * mainloop() 是整个程序的调度器，每个 eurasia 程序都必须要调用一次 mainloop() 以启动协程调度
  * httpserver.start() 和调度无关，只是让服务器进入请求监听状态
  * httpserver 可以有多个，而 mainloop() 只有一个

==CGI 规范适配==

httpfile 对象是整个服务器的关键接口，其设计在很大程度上与 CGI/1.1 规范适配，以下是一些对应关系：

|| 接口类型： || 接口描述： || CGI 对应： ||
|| dict get || httpfile.environ{{{[}}}_*envname*_{{{]}}} || 环境变量 ||
|| method || httpfile.read(_*size*=-1_, _*timeout*=-1_) || 标准输入 ||
|| method || httpfile.readline(_*size*=-1_, _*timeout*=-1_) || 标准输入 ||
|| method || httpfile.write(_*data*_, _*timeout*=-1_) || 标准输出 ||

可以通过 httpfile.environ{{{[}}}_*envname*_{{{]}}} 提取的环境变量有：

|| 环境变量： || 变量描述： || example： ||
|| REQUEST_METHOD || 请求的方法 || "GET"、"POST" ||
|| SERVER_PROTOCOL || 请求协议及版本 || "HTTP/1.1" ||
|| REMOTE_ADDR || 连入客户端的地址和端口 || ("192.168.0.2", 5566) ||
|| REMOTE_PORT || 连入客户端的端口 || 5566 ||
|| REQUEST_URI || 完整 uri || "/login?username=tom&passwd=***" ||
|| PATH_INFO || 页面地址 || "/login" ||
|| QUERY_STRING || 请求参数 || "username=tom&passwd=***" ||
|| CONTENT_TYPE || POST 等报文类型 || "application/x-www-form-urlencoded" ||
|| CONTENT_LENGTH || POST 等报文长度 || 999 ||
|| HTTP{{{_}}}_*HEADERNAME*_ || 请求头部 || 比如 HTTP_REFER 获得 "http://www.google.com/" ||

同样可以通过 httpfile.request_uri、httpfile.path_info、httpfile.query_string 取出相应环境变量并设置：

{{{
# 操作 httpfile.request_uri 会同时影响到 PATH_INFO 和 QUERY_STRING
httpfile.request_uri = '/login?username=tom&passwd=***'
print httpfile.path_info, httpfile.query_string  # 分别是 "/login" 和 "username=tom&passwd=***"
print httpfile.environ['PATH_INFO'], httpfile.environ['QUERY_STRING']  # 同上

# 操作 httpfile.path_info 会影响到 REQUEST_URI
httpfile.path_info = '/check'
print httpfile.request_uri  # uri 变成 "/check?username=tom&passwd=***"，query_string 不变
print httpfile.environ['REQUEST_URI']  # 同上

# 操作 httpfile.query_string 会影响到 REQUEST_URI
httpfile.query_string = 'username=jerry&passwd=***'
print httpfile.request_uri  # uri 变成 "/check?username=jerry&passwd=***"，path_info 不变
}}}

  * 对 httpfile.request_uri、httpfile.path_info、httpfile.query_string 进行设置这三个变量会联动
  * 设置 httpfile.environ 这三个变量_*不会*_发生联动，一般避免直接通过 httpfile.environ 操作这三个变量

==解读请求==

通过：

|| httpfile.read(_*size*=-1_, _*timeout*=-1_) ||

和

|| httpfile.readline(_*size*=-1_, _*timeout*=-1_) ||

可以直接读取 POST 等请求报文。

eurasia.cgietc 模块提供了用于解析 POST 形式表单的工具 form(_*httpfile*_, _*max_size*=1048576_, _*timeout*=-1_)：
  * 需要指定一个 httpfile 对象
  * 使用 max_size 限定允许用户提交表单的最大字节数，超过限制会抛出 ValueError 并立即杀死客户端，默认最多传输 1M 数据
  * 使用 timeout 指定读取表单的超时时间
  * 使用 dict 返回解析的表单
    * 正常情况下每个表单项的取值都是 str
    * 如果提交了多个同名的表单项，那么该表单项取值就是一个 list，在其中保存多个 str 值

{{{
# -*- conding: utf-8 -*-
from eurasia.cgietc import form
from eurasia.web import httpserver, mainloop

# 返回表单内容
def handler(httpfile):
    # 假定提交的表单：a=hello&b=world&c=1&c=2&c=3
    # 则输出 {'a': 'hello', 'b': 'world', 'c': ['1', '2', '3']}
    form1 = form(httpfile)
    httpfile.write(repr(form1))
    httpfile.close()
}}}

  * form() 会同时处理 QUERY_STRING 和 POST 报文体
  * 注意，_*不能*_处理 multipart 报文，比如文件上传
  * 注意，httpfile.read() / httpfile.readline() _*不能*_与 form() 混用，会导致接收内容混乱

==完成响应==

我们提供了接口：

|| httpfile.start_response(_*status*_, _*response_headers*_, _*timeout*=-1_) ||

用于替代 httpfile{{{[}}}_*headername*_{{{]}}} 和 httpfile.status 的作用。下面是一个例子：

{{{
def handler(httpfile):
    response_status = '200 OK'
    response_headers = [('Content-Type', 'text/html')]
    httpfile.start_response(response_status, response_headers)
    httpfile.sendall('hello world!')
    httpfile.close()
}}}

httpfile.start_response() 的作用是发送指定 status 和 headers 的报文头，这和 wsgi 规范（[http://www.python.org/dev/peps/pep-0333/ pep333]）中 start_response() 接口的定义相当接近。

通过 httpfile.start_response() 完成报文头部以后，就可以通过：

|| httpfile.sendall(_*data*_, _*timeout*=-1_) ||

发送具体的报文体了。

httpfile.write() 与 httpfile.sendall() 的功能相当接近，主要都用于发送报文体，他们的区别在于：
  * httpfile.write() 会判断头部如果没有发送，会首先发送 httpfile.status 和 httpfile{{{[}}}…{{{]}}} 的头部设置，再发送报文
  * httpfile.sendall() _*不会*_理会头部是否已发送，而直接发送报文，在没有调用 httpfile.start_response() 的情况下这会导致严重问题

一般情况下，httpfile.status、httpfile{{{[}}}…{{{]}}} 和 httpfile.write() 配合使用；httpfile.start_response() 则与 httpfile.sendall() 一起使用
  * 需要注意的是 httpfile.start_response() 会覆盖 httpfile{{{[}}}…{{{]}}} 和 htttpfile.status 的设定
  * 严格说 httpfile.start_response() 的头部内容会追加在 httpfile{{{[}}}…{{{]}}} 的设定之后

==长连接==

请求将被一直保持，直到你调用：

|| httpfile.close() ||

在此期间你可以在任何时候向用户发送内容。

{{{
# -*- coding: utf-8 -*-
from eurasia.web import httpserver, mainloop
clients = {}
def handler(httpfile):
    ip = httpfile.environ['REMOTE_ADDR']
    if ip not in clients: # clients 中没有一个具有相同 ip 的客户端，则保存一个
        # 开始这个请求，但是不立即结束
        httpfile.start_response('200 OK', [('Content-Type', 'text/html')])
        httpfile.sendall('<h1>begin</h1>') # 这条报文是立即返回给客户端的
        clients[ip] = httpfile # 在 clients 中保存当前 httpfile
        return

    if ip in clients: # 如果当前正维持着一个具有相同 ip 的客户端
        # 完成上一个未结束的请求
        httpfile2 = clients[ip] # 取出之前未结束的客户端
        httpfile2.sendall('<h1>end</h1>')
        httpfile2.close() # 完成响应

        # 保持本次请求
        httpfile.start_response('200 OK', [('Content-Type', 'text/html')])
        httpfile.sendall('<h1>begin</h1>')
        clients[ip] = httpfile

httpserver(':8080', handler).start()
mainloop()
}}}