#summary EURASIA 用户手册（3.1 版）
#labels Deprecated

<wiki:toc max_depth="2" /> 


|| || || ||
|| || ||
|| ||


=快速开始=

我们将从最简单的 hello world 开始，通过一些范例程序，快速掌握 eurasia 的特点。

这首先是一个 web 程序。


==hello world==

{{{
#!/usr/bin/python
#-*- coding: utf-8 -*-
#filename: test.py

from eurasia.web import httpserver, mainloop
def handler(httpfile):
    httpfile['Content-Type'] = 'text/html'
    httpfile.write('<html>hello world!</html>')
    httpfile.close()

httpd = httpserver(('', 8080), handler)
httpd.start()
mainloop()
}}}

简单地把 handler 绑定到本机的 8080 端口。所有发往这个端口的 http 请求都会得到一个 hello world 的响应。

执行脚本，启动服务器。

{{{
$/usr/bin/python2 test.py
}}}

  * 一次可以通过 httpserver 创建多个 http 服务器
  * http 服务器通过 start() 启动，用 stop() 暂停
  * mainloop() 主循环是每个 eurasia 程序都必须要有的


==httpfile 对象==

通过操作 httpfile 对象以获取用户请求并完成响应。

request 操作:

|| property || httpfile.method || 通常是“GET”或“POST” ||
|| property || httpfile.path_info || 请求的路径信息 ||
|| property || httpfile.query_string || 路径中“?”之后的部分 ||
|| property || httpfile.cookie || 得到客户端 cookie（Cookie.SimpleCookie 对象）无则返回 None ||
|| dict get || httpfile`[`_*headername*_`]` || 得到指定头部 ||

response 操作:

|| property || httpfile.status || http 响应状态，默认是 200 ||
|| property || httpfile.cookie || 向客户端发送一个 Cookie 对象（比如 Cookie.SimpleCookie） ||
|| dict set || httpfile`[`_*headername*_`]` || 发送指定头部 ||
|| method || httpfile.write(_*data*_, _*timeout*=-1_) || 发送指定内容，默认无超时 ||
|| method || httpfile.close(_*timeout*=-1_) || 完成并终止本次响应，默认无超时 ||

下面将是一个完整的例子（文件服务器）：

{{{
#-*- coding: utf-8 -*-
import os.path
from eurasia.web import httpserver, mainloop
def handler(httpfile):
    # 注意，直接组合路径不安全
    filename = '/var/www' + httpfile.path_info
    if not os.path.exists(filename):
        httpfile.status = 404 # 文件未找到
        httpfile.write('<h1>Not Found</h1>')
        return httpfile.close()
    if os.path.isdir(filename):
        httpfile.status = 403 # 不支持列出目录
        httpfile.write('<h1>Forbidden</h1>')
        return httpfile.close()
    httpfile['Content-Type'] = 'application/octet-stream'
    data = open(filename).read()
    httpfile.write(data)
    httpfile.close()

httpd = httpserver(('', 8080), handler)
httpd.start()
mainloop()
}}}

  * 虽然 httpfile 形似 dict，但是 dict get 仅用于读取 request 头部，dict set 仅用于写入 response 头部
    # 这意味着从 httpfile`[`...`]` 获取的内容和写入 httpfile`[`...`]` 的内容，一般_*并不匹配*_
    # httpfile.cookie 亦然

  * 这里直接对路径进行相加，_*是不安全的*_，仅用于演示
  * 这里对磁盘文件的读取操作会阻塞整个程序，eurasia 带有文件 IO 的协程版本，将于后文中详述


|| || || ||
|| || ||
|| ||


=标准 web 服务器=

进入正题。首先通过 httpserver(_*addr*_, _*handler*_) 创建标准 http 服务器。

==地址格式==

接口 httpserver 允许多种形式的 addr 参数。

{{{
httpserver('127.0.0.1:8080', handler)  # IPv4 地址，端口 8080
httpserver('[::1]:8080', handler)  # IPv6 地址
httpserver(':8080', handler)  # 本机 8080 端口
httpserver(('127.0.0.1', 8080), handler)  # IPv4
httpserver(('::1', 8080), handler)  # IPv6

# 同时指定地址及 family：
from socket import AF_INET6, AF_UNIX
from eurasia.web import httpserver
httpserver((('::1', 8080), AF_INET6), handler)
httpserver(('/var/httpd.sock', AF_UNIX), handler)  # unix socket

# 绑定到 fileno 为 0 的资源描述符，默认 family 是 AF_INET：
httpserver(0, handler)

# 绑定到 fileno 为 0 的描述符，指定 family 为 AF_INET6：
from socket import AF_INET6
from eurasia.web import httpserver
httpserver((AF_INET6, 0), handler)
}}}

==启动和暂停服务器==

通过 httpserver.start() 和 httpserver.stop() 启动和暂停服务器，暂停后的服务器可以通过 httpserver.start() 重新启动。

{{{
# -*- coding: utf-8 -*-
from eurasia.web import httpserver, mianloop

# 工作服务器，绑定到 8080 总是返回 hello world
def handler(httpfile):
    httpfile.write('hello world!')
    httpfile.close()

httpd = httpserver(':8080', handler)
httpd.start()

# 管理服务器，绑定到 8090
def manager(httpfile):
    # 如果请求地址是 /start 则启动工作服务器
    if httpfile.path_info == '/start':
        httpd.start()
   # 如果请求地址是 /pause 则停止工作服务器
    elif httpfile.path_info == '/pause':
        httpd.stop()

man = httpserver('8090', manager)
man.start()

# 执行调度
mainloop()
}}}

注意区分 httpserver.start() 和 mainloop()：
  * mainloop() 是整个程序的调度器，每个 eurasia 程序都必须要调用一次 mainloop() 以启动协程调度
  * httpserver.start() 和调度无关，只是让服务器进入请求监听状态
  * httpserver 可以有多个，而 mainloop() 只有一个

==CGI 规范适配==

httpfile 对象是整个服务器的关键接口，其设计在很大程度上与 CGI/1.1 规范适配，以下是一些对应关系：

|| 接口类型： || 接口描述： || CGI 对应： ||
|| dict get || httpfile.environ`[`_*envname*_`]` || 环境变量 ||
|| method || httpfile.read(_*size*=-1_, _*timeout*=-1_) || 标准输入 ||
|| method || httpfile.readline(_*size*=-1_, _*timeout*=-1_) || 标准输入 ||
|| method || httpfile.write(_*data*_, _*timeout*=-1_) || 标准输出 ||

可以通过 httpfile.environ`[`_*envname*_`]` 提取的环境变量有：

|| 环境变量： || 变量描述： || example： ||
|| REQUEST_METHOD || 请求的方法 || "GET"、"POST" ||
|| SERVER_PROTOCOL || 请求协议及版本 || "HTTP/1.1" ||
|| REMOTE_ADDR || 连入客户端的地址 || "192.168.0.2" ||
|| REMOTE_PORT || 连入客户端的端口 || 5566 ||
|| REQUEST_URI || 完整 uri || "/login?username=tom&passwd=***" ||
|| PATH_INFO || 页面地址 || "/login" ||
|| QUERY_STRING || 请求参数 || "username=tom&passwd=***" ||
|| CONTENT_TYPE || POST 等报文类型 || "application/x-www-form-urlencoded" ||
|| CONTENT_LENGTH || POST 等报文长度 || 999 ||
|| HTTP{{{_}}}_*HEADERNAME*_ || 请求头部 || （比如 HTTP_REFER：）"http://www.google.com/" ||

同样可以通过 httpfile.request_uri、httpfile.path_info、httpfile.query_string 取出相应环境变量并设置：

{{{
# 操作 httpfile.request_uri 会同时影响到 PATH_INFO 和 QUERY_STRING
httpfile.request_uri = '/login?username=tom&passwd=***'
print httpfile.path_info, httpfile.query_string  # 分别是 "/login" 和 "username=tom&passwd=***"
print httpfile.environ['PATH_INFO'], httpfile.environ['QUERY_STRING']  # 同上

# 操作 httpfile.path_info 会影响到 REQUEST_URI
httpfile.path_info = '/check'
print httpfile.request_uri  # uri 变成 "/check?username=tom&passwd=***"，query_string 不变
print httpfile.environ['REQUEST_URI']  # 同上

# 操作 httpfile.query_string 会影响到 REQUEST_URI
httpfile.query_string = 'username=jerry&passwd=***'
print httpfile.request_uri  # uri 变成 "/check?username=jerry&passwd=***"，path_info 不变
}}}

  * 对 httpfile.request_uri、httpfile.path_info、httpfile.query_string 进行设置这三个变量会联动
  * 设置 httpfile.environ 这三个变量_*不会*_发生联动，一般避免直接通过 httpfile.environ 操作这三个变量

==解读请求==

通过 httpfile.read(_*size*=-1_, _*timeout*=-1_) 和 httpfile.readline(_*size*=-1_, _*timeout*=-1_) 可以直接读取 POST 等请求报文。

eurasia.cgietc 模块提供了用于解析 POST 形式表单的工具 form(_*httpfile*_, _*max_size*=1048576_, _*timeout*=-1_)：
  * 需要指定一个 httpfile 对象
  * 使用 max_size 限定允许用户提交表单的最大字节数，超过限制会抛出 ValueError 并立即杀死客户端，默认最多传输 1M 数据
  * 使用 timeout 指定读取表单的超时时间
  * 使用 dict 返回解析的表单
    * 正常情况下每个表单项的取值都是 str
    * 如果提交了多个同名的表单项，那么该表单项取值就是一个 list，在其中保存多个 str 值

{{{
# -*- conding: utf-8 -*-
from eurasia.cgietc import form
from eurasia.web import httpserver, mainloop

# 返回表单内容
def handler(httpfile):
    # 假定提交的表单：a=hello&b=world&c=1&c=2&c=3
    # 则输出 {'a': 'hello', 'b': 'world', 'c': ['1', '2', '3']}
    form1 = form(httpfile)
    httpfile.write(repr(form1))
    httpfile.close()
}}}

  * form() 会同时处理 QUERY_STRING 和 POST 报文体
  * 注意，_*不能*_处理 multipart 报文，比如文件上传
  * 注意，httpfile.read() / httpfile.readline() _*不能*_与 form() 混用，会导致接收内容混乱
  * form() 处理完请求以后会将结果以 dict 对象返回，不会增加 httpfile 的引用

==完成响应==

我们提供了接口 httpfile.start_response(_*status*_, _*response_headers*_, _*timeout*=-1_) 用于替代 httpfile`[`...`]`（设置头部）和 httpfile.status 的作用：

{{{
def handler(httpfile):
    response_status = '200 OK'
    response_headers = [('Content-Type', 'text/html')]
    httpfile.start_response(response_status, response_headers)
    httpfile.sendall('hello world!')
    httpfile.close()
}}}

httpfile.start_response() 的作用是发送指定 status 和 headers 的报文头，这和 wsgi 规范（[http://www.python.org/dev/peps/pep-0333/ pep333]）中 start_response() 接口的定义相当接近。

通过 httpfile.start_response() 完成报文头部以后，就可以通过 httpfile.sendall(_*data*_, _*timeout*=-1_) 发送具体的报文体了。

httpfile.write() 与 httpfile.sendall() 的功能相当接近，主要都用于发送报文体，他们的区别在于：
  * httpfile.write() 会判断头部如果没有发送，会首先发送 httpfile.status 和 httpfile`[`...`]` 的头部设置，再发送报文
  * httpfile.sendall() _*不会*_理会头部是否已发送，而直接发送报文，在没有调用 httpfile.start_response() 的情况下这会导致严重问题

一般情况下，httpfile.status、httpfile`[`...`]` 和 httpfile.write() 配合使用；httpfile.start_response() 则与 httpfile.sendall() 一起使用
  * 需要注意的是 httpfile.start_response() 会覆盖 httpfile`[`...`]` 和 htttpfile.status 的设定
  * 严格说 httpfile.start_response() 的头部内容会追加在 httpfile`[`...`]` 的设定之后

==cookie==

通过 httpfile.cookie 属性配合标准库 [http://docs.python.org/library/cookie.html Cookie] 读取和设置 cookie。

{{{
#!/opt/unladen-2.6.4/bin/python2.6
# -*- coding: utf-8 -*-
from uuid import uuid4
from Cookie import SimpleCookie
from time import gmtime, strftime, time
from eurasia.web import httpserver, mainloop

def handler(httpfile):
    cookie = httpfile.cookie
    if cookie is None:  # 客户端没有 cookie 则设置一个
        cookie = SimpleCookie()
        cookie['uid'] = uuid4().hex
        cookie['uid']['path'] = '/'
        cookie['uid']['expires'] = strftime(  # 设置过期时间是 3600 秒
            '%a, %d-%b-%Y %H:%M:%S GMT', gmtime(time() + 3600))
        httpfile.cookie = cookie # 设置到 httpfile.cookie
        # 通过 start_response()，cookie 随头部一起发送
        httpfile.start_response('200 OK', [('Content-Type', 'text/html; charset=utf-8')])
        httpfile.sendall('<p>创建 cookie 内容：<br><br>%s</p>'%cookie.output(header=''))
        httpfile.sendall('<p><b>该 cookie 已发送至浏览器</b></p>')
        httpfile.close()
    else:  # 客户端已有 cookie，删除该 cookie
        cookie_from_request = httpfile.cookie
        cookie_to_response  = SimpleCookie()
        cookie_to_response['uid'] = ''
        cookie_to_response['uid']['path'] = '/'
        cookie_to_response['uid']['expires'] = 'Mon, 26 Jul 1997 05:00:00 GMT'  # 使过期删除

        httpfile.cookie = cookie_to_response  # 在头部发送前设置好 cookie
        httpfile.start_response('200 OK', [('Content-Type', 'text/html')])
        httpfile.sendall('<p>收到 cookie 内容：<br><br>%s</p>'%cookie_from_request.output(header=''))
        httpfile.sendall('<p><b>该 cookie 已经删除</b></p>')
        httpfile.close()

httpserver(':8080', handler).start()
mainloop()
}}}

  * 读取 httpfile.cookie 仅用于读取 request 头部，设置 httpfile.cookie 仅用于写入 response 头部
    * 这意味着从 httpfile.cookie 获取的内容和写入 httpfile.cookie 的内容，一般_*并不匹配*_

  * httpfile.cookie 的设置通过 httpfile.start_response() 或者 httpfile.write() 调用发送给浏览器
  * 注意，写入 httpfile.cookie 的内容与从 httpfile.cookie 读取的内容_*并不*_一定匹配
  * httpfile.cookie 的所有功能都可以直接通过 Cookie 和 Set-Cookie 头部的处理来完成
  * 出于安全性考虑，应仅使用 Cookie.SimpleCookie() 来存取 cookie

==长连接==

请求将被一直保持，直到你调用 `httpfile.close()` 在此期间你可以在任何时候向用户发送内容。

{{{
# -*- coding: utf-8 -*-
from time import strftime
from eurasia.socket2 import error
from eurasia.web import httpserver, mainloop
httpfiles = set()
def handler(current_httpfile):
    response_headers = [('Content-Type', 'text/html; charset=utf-8')]
    current_httpfile.start_response('200 OK', response_headers)
    current_httpfile.sendall(strftime('[%a, %d-%b-%Y %H:%M:%S GMT] 我加入了<br/>'))
    # 通知其他在线用户，有新人加入
    disconnected_httpfile = []
    for httpfile in httpfiles:
        try:
            # 告诉其他在线用户
            httpfile.sendall(strftime('[%a, %d-%b-%Y %H:%M:%S GMT] 又有新人加入<br/>'))
        except error:
            # 连接已断开
            disconnected_httpfile.append(httpfile)
    # 移除断开的 httpfile
    for httpfile in disconnected_httpfile:
        httpfiles.remove(httpfile)
    # 将当前客户端加入全局列表中
    httpfiles.add(current_httpfile)
httpserver(':8080', handler).start()
mainloop()
}}}

  * 请使用 firefox 浏览器观看此样例，因为缓存原因一些浏览器可能不能展现即时效果
  * handler 结束时如果其他地方没有保存 httpfile 的样本，因为引用计数的原因 httpfile 将被销毁，并断开用户连接
  * httpfile.start_response()、httpfile.sendall() 与 httpfile.write() 都将立即向客户端发送数据，_*不会*_缓存数据

==javascript rpc==

通过 eurasia.cgietc 提供的 browser(_*httpfile*_, _*domain*=None_, _*timeout*=-1_) 接口，服务器端可以在任何时候即时调用客户端的 javascript 函数。

在下面这个例子中，每当有新用户访问站点，所有在线用户都将收到一条 javascript 的提醒。

我们首先定义一个包含有 javascript 的 html 页面, 并与服务器建立一条长连接。 其中的 "my_alert" 函数就是我们即将要用到的:

{{{
<html>
<head>
<script language="JavaScript">
function my_alert(stuff) { alert(stuff); };
</script>
</head>
<body>
<!-- 与 /remotecall 位置的服务器脚本建立长连接 -->
<iframe src="/remotecall" style="display: none;"></iframe>
</body
</html>
}}}

下面是完整的处理脚本:

{{{
#-*- coding: utf-8 -*-
from eurasia.socket2 import error
from eurasia.cgietc import browser
from eurasia.web import httpserver, mainloop

page = '''\
<html>
<head>
<script language="JavaScript">
function my_alert(stuff) { alert(stuff); };
</script>
</head>
<body>
<!-- 与 /remotecall 位置的服务器脚本建立长连接 -->
<iframe src="/remotecall" style="display: none;"></iframe>
</body
</html>
'''
# 保存了所有在线用户的全局列表
global_browsers = set()

def handler(httpfile):
    if httpfile.path_info != '/remotecall':
        httpfile.start_response('200 OK', [('Content-Type', 'text/html')])
        httpfile.sendall(page) # 输出前面定义的上传表单
        return httpfile.close()
    # 创建 Browser 对象
    # 调用客户端名为 "my_alert()" 的 js 函数
    current_browser = browser(httpfile)
    current_browser.my_alert(u'我加入啦!')
    # 通知其他在线用户, 有新人加入
    disconnected = []
    for browser in global_browsers:
        try:
            # 调用在线用户的 my_alert 函数
            browser.my_alert(u'又有新人加入啦!')
        except error: # 已经断开连接
            disconnected.append(browser)
    # 移除已经断开连接的浏览器
    for browser in disconnected:
        disconnected.remove(browser)
    # 将当前浏览器添加到全局浏览器对象列表中
    global_browsers.add(current_browser)

httpserver(':8080', handler)
mainloop()
}}}

  * browser 接口的 domain 参数用于指定 javascript 域（document.domain）方便跨域调用
  * browser 接口的 timeout 参数用于指定建立 js rpc 连接的超时时间
  * browser 会增加一次 httpfile 的引用，在没有引用时，与用户的连接会自动断开

==keep-alive==

如果浏览器支持 keep-alive 特性，服务器将会自动以 keep-alive 方式处理浏览器请求。

  * 每一个请求都将是长连接（需要浏览器支持，目前主流浏览器都具有此特性），服务器没有连接数上的限制
  * 使用 httpfile.close() 接口完成本次请求，并继续保持连接
  * 使用 httpfile.shutdown() 断开连接（无论是否完成）

==超时处理==

多数 web 接口可以通过 timeout 参数设置超时，timeout 是以秒为单位的浮点数（float），默认值 -1 意为无超时。

{{{
# -*- coding: utf-8 -*-
from eurasia.cgietc import form
from eurasia.core import timeout  # 超时异常
from eurasia.web import httpserver, mainloop

def handler(httpfile):
    try:
        form1 = form(httpfile, max_size=10240, timeout=30.)  # 30 秒超时
    except timeout:
        httpfile.shutdown()  # 中断连接
    try:
        httpfile.write(repr(form1), timeout=10.)  # 10 秒超时
    except timeout:
        httpfile.shutdown()
    httpfile.close()  # 正常结束请求

httpd = httpserver(':8080', handler)
httpd.start()
mainloop()
}}}

  * 中断发生时会抛出 eurasia.core.timeout 异常，但是连接并不会随之中断
  * 用户仍然可以恢复因为超时中断的工作，这可能会导致一些潜在问题，因此建议终止连接后进行重试
  * 如果不捕获 timeout，异常将会传递到顶层，自动终止本次请求，断开连接