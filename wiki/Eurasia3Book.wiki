#labels Featured,Phase-Deploy,Phase-Support
=Eurasia 3.0 用户指引=

http://eurasia.googlecode.com/files/cctv.jpg

_(当然了, 也是女人的最爱)_

===欢迎进入 Eurasia3 魔幻世界===

_本文档尚在编写阶段, 关于 Eurasia3 技术的任何问题可以向 [http://groups.google.com/group/eurasia-users Eurasia 邮件列表]提出, 感谢您的支持 :) _

[http://code.google.com/p/eurasia/wiki/Eurasia3Demo Eurasia3 Demo] 是一份全面展示 Eurasia3 功能, 且颇为可读的范例文档。

在本文档尚未完成之前, 阅读 [http://code.google.com/p/eurasia/wiki/Eurasia3Demo Eurasia3 Demo] 可以获取 Eurasia3 更多的高级功能。

_──── 2007 年 12 月 2 日, 沈崴于太湖南岸_

===在阅读本文档之前===

本文档不是 HTTP 协议的小灶, HTTP 协议的相关知识对 Eurasia3 来说不是必须的,

但对您了解、使用 Eurasia3 来说会很有帮助。

==勾人胃口的入门级功能==

Eurasia3 当然也照例实现了一些常规 Web 框架的功能, 不错, 重复制造了轮子。

不过请相信我, Eurasia3 所关注的并不是这些 ──── 他只是顺手实现了而已。

──── 尽管 Eurasia3 似乎要做得更好些。

===在所有事情开始之前, 您需要 ──── 安装===

您需要:
 * Unix 或兼容系统
 * Stackless Python 2.5 或更高版本

很废柴, 其实这里不必贴过程出来的 ……

{{{
tar xzf Eurasia-3.x.x.tar.gz
cd Eurasia-3.x.x
/PATH/TO/STACKLESS/bin/python2.5 setup.py install
}}}

===Hello world!===

现在, 是时候编写我们第一个 Web 服务器了。

{{{
from Eurasia.web import config, mainloop

def controller(client):
	print >> client, (
	'HTTP/1.1 200 OK\r\n'
	'Content-Type: text/plain\r\n'
	'\r\n'
	'hello world!' )

	client.shutdown()

config(
	controller = controller,
	port       = 8080,
	verbose    = True )

if __name__ == '__main__':
	mainloop()
}}}

启动服务器:

{{{
/PATH/TO/STACKLESS/bin/python2.5 hello.py
}}}

现在, 您可以尝试访问 'http://localhost:8080/' 这个地址了。

===client 参数===

参数 "client" 提供的一些重要信息:

||client.path||提供了请求的 url, 是一个从根 ("/") 开始的字符串||
||client.method||提供了请求的方法, 通常是 "get" 或者 "post" (小写)||
||client.address||提供了请求者的 IP 以及端口信息||
||client['header-name']||提供了对 HTTP 头 (Header) 的访问, 注意, "header-name" 应该是小写的||
||client.uid||传说中的 Session Id, 具体用法后面会讲到||
||client.pid||传说中的 Socket fileno||
||client.closed||设为 True, 则 Eurasia3 会自动关闭和浏览器的连接||
||client.wfile||当前准备发送的数据 _于 Eurasia3 系统调度时自动发送_, 不常用||

好的, 您现在知道如何取 POST 报文长度了吗?

很简单, 使用 `client['content-length']` 就可以了, *注意* 请小写 "header-name"!

让我们回顾一下第一个 "hello world" 程序, client 还提供了以下两个方法:

||client.write(str)||向浏览器写数据||
||client.shutdown()||和 client.closed = True 不同, shutdown 会 *立即* 关闭到浏览器的连接||

事实上, 对于基于 GET 方法的简单 HTTP 请求, client 已经可以应付了。

*注意* , 以 client 来处理请求远没有您想像中那么小儿科,

他能将动态页面的响应能力提高到接近或者超过 Apache (静态页面响应速度) 的程度, 显然这是比较恐怖的。

===我们照例提供 Response 接口===

当然了, 下面您会发现, client 参数能做到 Response 接口所有的事情

──── 只是 Response 更酷而已。

{{{
from Eurasia.web import config, mainloop
from Eurasia.web import Response

def controller(client):
	resp = Response(client)

	resp['Content-Type'] = 'text/html; charset=utf-8' # 我可以写 Header 了!

	print >> resp, 'hello world!'
	#resp.write('hello world!') # 这样也行

	resp.close()

config(
	controller = controller, port = 8080,
	verbose = True )

mainloop()
}}}

Response 最大的贡献是: 它帮您写 Header。

===你在找表单变量吗?===

Form 来啦!

当 URL 是 `"http://localhost:8080/?a=1&b=2"` 时, Form 能得到这些提交的表单变量。

Form 是这样的一个字典: `{'a': 1, 'b': 2}`。然后, POST 方法也是支持的。

{{{
from Eurasia.web import config, mainloop
from Eurasia.web import Response, Form, OverLimit

def controller(client):
	resp = Response(client)
	resp['Content-Type'] = 'text/html; charset=utf-8'

	try:
		form = Form(client,

			max_size=10000) # 限制 Form (POST 模式) 上传内容的大小
			                # 默认 1048576 字节

		        	        # 当 form 超过限制, 会得到 OverLimit 异常
			                # client 会自动 shutdown
	except OverLimit:
		# client 已经 shutdown, 我除了写日志无事可干

		# 通常情况下, 我在 HTML 页面里已经限制了可提交内容的大小,
		# 这应该是一次 Crack 行为
		pass


	print >> resp, '你的表单提交了这些变量:',
	for key, value in form.items():
		print >> resp, key, '->', value

	resp.close()

config(
	controller = controller, port = 8080,
	verbose = True )

mainloop()
}}}

===我们还有 Request 接口===

Request 恰和 Response 相反, Request 可以读取 POST 报文的 Body 部分。

但是请注意, 不是 GET 报文 (GET 报文没有 Body), 否则您将得到一个 MethodError 异常。

{{{
from Eurasia.web import config, mainloop
from Eurasia.web import Request, Response, MethodError, OverLimit

def controller(client):
	resp = Response(client)
	resp['Content-Type'] = 'text/html; charset=utf-8'
	try:
		req  = Request(client,

			max_size=10000 ) # 超出 10000 字节, 读取时将抛出 OverLimit 异常
			                 # (而 Form 的 OverLimit 是发生在初始化时)
			                 # 服务器将自动关闭

		        	         # 默认 1048576 字节
	except MethodError:
		print >> resp, '[Request 接口只支持 POST 方法]'
		resp.close()
		return

	try:
		s  = req.read(100)     # 我可以这么读
		s += req.readline(100) # 也可以这么读
		s += req.readline()    # 还可以这么读
		s += req.read()        # shut up, 读取所有内容 now!
	except OverLimit:
		# client 已经挂掉, 我无事可干
		return

	print >> resp, s
	resp.close()

config(
	controller = controller, port = 8080,
	verbose = True )

mainloop()
}}}

下面是天杀的测试页面, 贴到本地文件里, 用浏览器打开吧 (也别忘了启动上面的服务器程序)。

{{{
<html>
<!-- 我是测试页面, 我会发出 POST 数据 -->
<form method="post" action="http://localhost:8080/">
<input type="text" name="a" value="...">
<input type="text" name="b" value="...">
<input type="submit">
</form>
</html>
}}}

最后, Form 是基于 Request 实现的。

可想而知, 在遇到 POST 请求时 Form 调用的是 Request.read(), 读完整个 POST 报文。

因此, 在*绝大多数情况下请勿*混用 Form 和 Request。

===Response 和 Request 的比较研究===

||接口名称||Client||Response||Request||Form||
||uid 属性||读取 Session Id||写 Session Id||读取 Session Id||读取 Session Id||
||pid 属性||读取 Socket fileno|| ||读取 Socket Fileno||读取 Socket Fileno||
||read(size=None)|| || ||读取 POST 报文体|| ||
||readline(size=None)|| || ||行读取 POST 报文体|| ||
||write(s)||直写, 立即发生 IO 行为||写缓冲区|| || ||
||close()|| ||写出缓冲区, 并关闭连接|| || ||
||`__getitem__`|| || ||取 HTTP Header||读取表单||
||`__setitem__`|| ||向缓冲区写 HTTP Header|| || ||

Response 与 Request 基本上是一一对应的, 互为逆操作。

===恐怖的 IO 错误!===

当我们使用 Eurasia3 时, 如果我们未将 POST 报文读取完成便开始向浏览器进行回复,

我们将得到一个 IOError, 并杀死这个 Socket (Client)。

所以在遇到 POST 报文时, 在进行 Response 之前, 我们需要先使用 Request.read() 读完整个 POST 报文。

当然最简单地, 调用 Form 接口, Form() 调用会自动读取整个 POST 请求。

当然使用上面的 Response 对象, Response.write() 并不会立即产生 IO,

只有在执行 Response.close() 时才会有实际的发送操作,

因此对 Response 来说, 你可以边读边写。

而 Client.write() 会立即产生 IO, 因此 Client.write()

必须在 Request 完成所有 POST 报文的读操作之后调用。

===好了, 休息一下===

上面的内容是任何一个正常的 Web 框架都会有的, 哦, 顺便说一下

下面这一章的内容也是任何一个 Web 框架都会有的, 只是

让 Eurasia3 更像一个正常的框架而已。

好吧, 让我们进阶吧 ...

.

.

.

==像 Cherrypy 和 Django 那样工作==

绝大多数黑客在第一时间内都会发现 Eurasia3 其实是一个比 Django 更为底层的框架。

当然, 更底层并不意味着更难用 ──── 高级而难用的框架我们已经见得太多了。

所以, 答案是: Eurasia3 是直接可用的框架, 我们需要关心的仅仅是

该穿上 Cherrypy 还是 Django 的马甲工作

──── 或者更酷。

===我是 Cherrypy 了啦!===

{{{
# cherrypy.py

from Eurasia.web import config, mainloop, \
	Form, Response
from traceback import print_exc

def expose(func):
	func.exposed = True

def controller(client):
	resp = Response(client)

	p = client.path.find('?')
	path = p == -1 and client.path or client.path[:p]
	node = root
	for i in path.split('/')[1:]:
		if not i: continue

		try:
			node = getattr(node, i)
		except AttributeError:
			break

	try:
		try:
			if node.index.exposed:
				print >> resp, node.index(**Form(client))
		except AttributeError:
			if node.exposed:
				print >> resp, node(**Form(client))

	except:
		resp['Content-Type'] = 'text/plain'
		print_exc(file=resp)

	resp.close()

def quickstart(inst):
	globall root; root = inst
	config(
		controller = controller, port = 8080,
		verbose = True )

	mainloop()

root = None
}}}

这样一个简单的 CherryPy 就完成了,

下面我们试一下 [http://www.cherrypy.org CherryPy.org 首页] 上的范例程序:

{{{
import cherrypy

class HelloWorld:
	def index(self):
		return "Hello world!"
	index.exposed = True

cherrypy.quickstart(HelloWorld())
}}}

We assumed that you already have installed CherryPy.

Copy this file and save it locally as hello.py,

then start the application at the command prompt:

{{{
python hello.py
}}}

CherryPy 是一个可尊敬的框架, 早期特别是 Eurasia2 受 CherryPy 影响非常大,

所以这个例子只是用来说明让 Eurasia3 像 CherryPy 那样工作是非常容易的, 并没有轻视它的意思

──── 其实真正的 CherryPy 还是颇为复杂的。

而 Eurasia3 出现以后, 编写一个自己的框架, 已经变得非常容易。

_通常使用 Eurasia3 模仿的框架比起原框架会拥有[http://groups.google.com/group/eurasia-users/browse_thread/thread/310b19fb3497ee67 更高的页面效率和并发承受力]_

===其实我是 Django===

{{{
from re import compile
from Eurasia.web import config, mainloop

def hello(resp, *args, **kw):
	print >> resp, 'hello:', args, kw
	resp.close()
def world(resp, *args, **kw):
	print >> resp, 'world:', args, kw
	resp.close()

urlpatterns = (
	(r'^/hello/[^/]+/(?P<foo>.*)', hello),
	(r'^/world/[^/]+/(?P<bar>.*)', world)  )

def controller(client):
	path = client.path
	for pattern, func in urlpatterns:
		match = pattern.search(path)
		if match:
			func(client, *(match.groups()),
				**(match.groupdict()) )
			return

	print >> client, '404'
	client.shutdown()

urlpatterns = tuple(
	[(compile(pattern), func) for pattern, func in urlpatterns])

config(
	controller = controller, port = 8080,
	verbose = True )

mainloop()
}}}

===其实我还是 web.py===

哦 …… OK, 我承认这是一个不怀好意的玩笑。

因为 Eurasia3 所有的 Web 功能也是在一个独立的 web.py 文件中的。

事实上 Eurasia3 所有的模块都是 "松散耦合" (哦 Django 好像也是这么说的) 的,

──── 我的意思是, Eurasia3 中的所有文件互相都完全没有关系。

||文件||功能||
||web.py||Web 功能||
||pyetc.py||配置文件读取功能 _以后会讲到_||
||daemon.py||守护进程模块 _以后会讲到_||

现在把 web.py 从 Eurasia 目录中拿出来, 我们就拥有了一个 "web.py"。

{{{
import web
...
}}}

===好了, 休息一下===

到此, Eurasia3 作为传统框架的内容已经全部结束,

下面就让我们开始深入 Eurasia3 的精髓 ...

.

.

.

==Eurasia3 是基于 Stackless 的框架==

前面那些冗长而无聊的内容或许会让我们忽视了这一点 ──── 噢, 这令人震惊的事实。

Stackless! 确实会令许多人迷惑, 作为入门我确实很推荐 Stackless 官网上的这份 [http://members.verizon.net/olsongt/stackless/why_stackless.html 文档]。

这里是 [http://lych.yo2.cn Lych (边緣獨行者)] 杰出的 [http://l.99081.com/lych/stackless.html 翻译版本], 另外你还可以试一下 [http://gashero.yeax.com/?p=30 这个地址 (校对者 Gashero 的 Blog "惊帆之静默")], 感谢 [http://lych.yo2.cn Lych] 和 [http://gashero.yeax.com Gashero]!

当然啦, 使用 Eurasia3 其实并不需要太高深的 Stackless 知识

──── 即使你不知道 Stackless, 你也能把 Eurasia3 用得很好, 就像前两节一样。

===Eurasia3 是单线程的===

对 Stackless 用户来说, 这没有什么大不了的 ──── 单线程嘛, 和 1M 个线程没什么区别, 是吧?

===controller 是一个 tasklet===

是啊, 我承认在前面把 controller 说得和一个函数一样, 但 controller 确确实实是一个 *tasklet* 。

──── 换句话说, controller 是一个 "线程", 一个 ──── 协作线程。

明白这一点之后, 我们对 controller 应该有些新的想法, 比如说:
  # 当遇到耗时操作, 我们应该使用 stackless.schedule() 以交出 CPU, 防止影响其他请求
  # 绝大多数情况下, 耗时操作很少出现
  # 我不能真的把自己给阻塞了
  # IO 应该交给另一个进程来做
  # 协作线程之间没有临界资源
  # 任何全局变量都可以作为协程间安全的通信方式
  # stackless.channel() 这个工具很好, 很强大

仿佛是这个样子:

{{{
import stackless

def controller(client):
	# 当有耗时操作时

	执行耗时操作的第一个步骤
	stackless.schedule()
	执行耗时操作的第二个步骤

	# 协作线程的专利: 广播
	global broadcast

	print >> client, '当前广播:', broadcast

	broadcast.append(`client.pid` + '向您广播')
	stackless.schedule() # 让其他人有机会收听

	# 当需要和其他线程通信时
	#
	# 等待信息
	channels[client.pid] = stackless.channel()
	print >> client, '收到消息', channels[client.pid].receive()

	# 发送信息
	channels[某个浏览器线程.pid].send(`client.pid` + '向您发送消息')

broadcast = []
channels  = {}
}}}

===Eurasia3 是基于 Stackless 的框架===

这里的意思是, Eurasia3 永远不会害你:
  * Eurasia.web.sleep(sec) 不会真正阻塞掉整个服务器 (他不是 time.sleep)
  * Eurasia3 中所有的 IO 操作都 "不是" IO 操作 ──── 他们会不停交出 CPU

──── 所以请放心使用, 您不必像下面的程序那样过度小心:

{{{
from Eurasia.web import sleep, schedule

def controller(client):
	...

	for i in xrange(100):
		sleep(0.01)
		schedule()    # XXX

	client.write(s)
	schedule()            # XXX

	...
}}}

轻松点, 不要太紧张。

{{{
def controller(client):
	...

	sleep(1)
	client.write(s)

	...
}}}

下面是 Eurasia3 中和 IO 相关的接口 (常规接口) 自动调用 schedule 交出 CPU 的情况:

||*IO 操作名称*||*使用 schedule?*||
||Client.write(s)||yes||
||Client.shutdown()||no||
||Response.write(s)||no||
||Response.close()||yes||
||Request.read(size)||yes||
||Request.readline(size)||yes||
||Form(client, max_size)||yes||

下面是很快会涉及到的流式 IO 接口的情况:

||*IO 操作名称*||*使用 schedule?*||
||_流式_ Response.begin()||yes||
||_流式_ Response.write(s)||yes||
||_流式_ Response.end()||no||
||Pushlet.begin()||yes||
||Pushlet.RemoteCall(...)||yes||
||Pushlet.end()||no||
||SimpleUpload(client, max_size)||yes||
||SimpleUpload.read(size)||yes||
||SimpleUpload.readline(size)||yes||

对 controller 线程而言, 调用 Eurasia3 的 sleep 和 IO 接口,

线程都会假装阻塞在那里, 但事实上都是安全的。

===Eurasia3 确实不支持多 CPU 及多核 CPU, 但是 ...===

上面已经说了, Eurasia3 是单线程的 Python 程序, 因此支持多 CPU 及多核 CPU 的机会相当渺茫了。

──── 我承认支持多 CPU 及多核 CPU 是一个卖点, 但是这确确实实被 Eurasia3 忽视了。

如果我告诉你这是人为的, 你确实有理由愤怒。

事实上在 Eurasia3 设计之初, 就已经考虑到了这个问题, 然而这并不真的是一个问题,

或者说在 Unix 下这不是一个问题。

对 Unix 程序员而言, 多 CPU、多核 CPU 与多台服务器并没有什么区别。我们自然会这样做:
  * 若有多台服务器或 CPU, 则使用多个 Eurasia3 进程进行进程间通信及负载均衡。
  * 倾向于将 IO 操作扔给专门的 IO 服务器或者进程 (Zope 中的 ZEO?)。
  * 将高负荷数据运算扔给专门的运算进程。

──── 这是 Unix 程序员与生俱来的本能。

放心吧, CPU 肯定会被用完的, 我们真正应该奇怪的是: 为什么会有 "多核 CPU" 这种奇怪的东西。

===好了, 休息一下===

下面是 Eurasia3 的核心, HTTP 长连接!

.

.

.

==走近 Pushlet==

= 未完待续 …… =