#!<<PYTHON>>
import sys
def usage():
	print 'usage: %s [start | stop | status | tiny [name]]' %sys.argv[0]
	sys.exit(0)

try:
	command = sys.argv[1]
except IndexError:
	usage()

if command not in ['tiny', 'start', 'status', 'stop']:
	usage()

from os.path import dirname, abspath, join as path_join
base = abspath(path_join(dirname(__file__), '..'))

sys.path.append(base)
sys.path.append(path_join(base, 'lib'))

def load():
	from eurasia import pyetc
	daemon_config = type('daemon_config', (), {})
	def config(**args):
		if 'address' not in args:
			print >> sys.stderr, 'error: daemon address is required'
			sys.exit()

		if 'program' not in args:
			print >> sys.stderr, 'error: daemon program is required'
			sys.exit()

		daemon_config.address, daemon_config.program = args['address'], args['program']

	class Products(object):
		def __getattr__(self, name):
			return self

	env = dict(
		bin = lambda filename: path_join(base, 'bin', filename),
		etc = lambda filename: path_join(base, 'etc', filename),
		lib = lambda filename: path_join(base, 'lib', filename),
		tmp = lambda filename: path_join(base, 'tmp', filename),
		var = lambda filename: path_join(base, 'var', filename),

		config = lambda **args: None, Server = lambda **args: None,
		Daemon = config, Products = Products())

	data = pyetc.load(env['etc']('eurasiad.conf'), env=env)
	daemon_config.verbose = bool(data.verbose) if hasattr(data, 'verbose') else False
	return daemon_config

if command == 'tiny':
	if len(sys.argv) > 3:
		usage()

	from eurasia import utility

	config = load()
	if not config.verbose:
		utility.dummy()

	args = (config.program, sys.argv[2]) if len(sys.argv) > 1 else (config.program, )
	utility.daemonize(*args)

if len(sys.argv) != 2:
	usage()

import os
from os import fork
from time import sleep
from sys import stdout, stderr
from traceback import print_exc
from socket import error as SocketError
from eurasia.daemon import Daemon, ServerProxy, Fault, \
	error as DaemonError

def start():
	config = load()
	try:
		daemon = Daemon(
			address=config.address,
			program=config.program, 
			verbose=config.verbose )

		print 'daemon manager started'

		pid = fork()
		if pid != 0:
			daemon()
		else:
			check(config)

	except DaemonError, msg:
		print 'daemon manager not running (%s)' %msg
	except:
		print_exc(file=stderr)

def check(config):
	sleep(0.5)
	print
	stdout.write('checking ')
	stdout.flush()

	for i in xrange(3):
		stdout.write('.')
		stdout.flush()
		sleep(0.6)

	try:
		daemon = ServerProxy(config.address)
		status = daemon.status()

		if status == 'running':
			print ' daemon process started'

		elif status == 'stopped':
			stdout.write(' daemon process not running; stopping daemon manager ... ')

			stop()
		else:
			print ' daemon process %s' %status

	except SocketError:
		print ' daemon manager not running'
	except:
		print_exc(file=stderr)

	stdout.write('(press "Enter" to continue)')

def stop():
	config = load()
	try:
		daemon = ServerProxy(config.address)
		daemon.stop()

		print 'daemon process stopped'

	except SocketError:
		print 'daemon manager not running'

	except Fault:
		print 'daemon manager halted'
	except:
		print_exc(file=stderr)

def status():
	config = load()
	try:
		daemon = ServerProxy(config.address)
		status = daemon.status()

		if status == 'running':
			print 'program running'

		elif status == 'stopped':
			stdout.write(('daemon manager running; daemon process not running; '
				'stopping daemon manager ... ' ))

			stop()
		else:
			print 'daemon manager running; program %s' %status

	except SocketError:
		print 'daemon manager not running'
	except:
		print_exc(file=stderr)

if command == 'start':
	start()

elif command == 'stop':
	stop()

elif command == 'status':
	status()
